// Generated by CoffeeScript 1.4.0
(function() {
  var ChannelManager, RedisHelper, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  RedisHelper = require('./RedisBase').RedisHelper;

  _ = require("underscore");

  ChannelManager = (function() {

    function ChannelManager(options) {
      this.gotMessage = __bind(this.gotMessage, this);

      this.extractChannelKey = __bind(this.extractChannelKey, this);

      var defaults, key, value;
      defaults = {
        delimiter: "|",
        client: null,
        cleanup: 120000,
        base: 'messages'
      };
      options = _.extend({}, defaults, options);
      for (key in options) {
        value = options[key];
        if (value) {
          this[key] = value;
        } else {
          throw "Expected " + key + " for channel manager";
        }
      }
      this.channels = {};
      this.client.on('message', this.gotMessage);
    }

    ChannelManager.prototype.extractChannelKey = function(channel) {
      return channel.split(this.delimiter)[1];
    };

    ChannelManager.prototype.gotMessage = function(channel, message) {
      var userid;
      userid = this.extractChannelKey(channel);
      if (this.channels[userid]) {
        return _.each(this.channels[userid].subscribers, function(subscriber, uniq) {
          if (!subscriber.callback([message])) {
            return subscriber.messages.push(message);
          }
        });
      }
    };

    ChannelManager.prototype.getNextMessage = function(userid, uniq, callback) {
      var _ref;
      console.log("About to get next method");
      if ((_ref = this.channels[userid]) != null ? _ref.subscribers[uniq] : void 0) {
        console.log("found subscriber");
        clearTimeout(this.channels[userid].subscribers[uniq].cleanupTimeout);
        this.channels[userid].subscribers[uniq].cleanupTimeout = this.setCleanup(userid, uniq);
        if (this.channels[userid].subscribers[uniq].messages.length > 0) {
          console.log("messages already waiting");
          if (callback(this.channels[userid].subscribers[uniq].messages)) {
            console.log("callback succeeded");
            return this.channels[userid].subscribers[uniq].messages = [];
          }
        } else {
          console.log("waiting for next message");
          return this.channels[userid].subscribers[uniq].callback = callback;
        }
      } else {
        throw "SubscriptionLost";
      }
    };

    ChannelManager.prototype.listen = function(userid) {
      var uniq;
      if (!this.channels[userid]) {
        this.channels[userid] = {
          uniq: 0,
          subscribers: {}
        };
        this.client.subscribe(this.buildChannelKey(userid));
      }
      uniq = this.channels[userid].uniq++;
      this.channels[userid].subscribers[uniq] = {
        messages: [],
        callback: null,
        cleanupTimeout: this.setCleanup(userid, uniq)
      };
      return uniq;
    };

    ChannelManager.prototype.buildChannelKey = function(userid) {
      return RedisHelper.buildKey(this.delimiter, [this.base, userid]);
    };

    ChannelManager.prototype.setCleanup = function(userid, uniq) {
      var _this = this;
      return setTimeout(function() {
        console.log("cleaning up " + userid + ":" + uniq);
        if (_this.channels[userid] != null) {
          if (_this.channels[userid].subscribers[uniq] != null) {
            delete _this.channels[userid].subscribers[uniq];
          }
          if (!(Object.keys(_this.channels[userid].subscribers).length > 0)) {
            _this.client.unsubscribe(_this.buildChannelKey(userid));
            return delete _this.channels[userid];
          }
        }
      }, this.cleanup);
    };

    return ChannelManager;

  })();

  exports.ChannelManager = ChannelManager;

}).call(this);
